<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Medieval Citybuilder and RTS</title>
  <style>
    body {
      margin: 0;
      background-color: #333;
      overflow: hidden;
      font-family: 'Times New Roman', serif;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="battleCanvas"></canvas>
  <script>
    // --- Canvas Setup ---
    const canvas = document.getElementById("battleCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
    
    // --- Global Variables ---
    let units = []; // Includes Lords, Knights, and Workers.
    let castles = [];
    let resourceNodes = [];
    let animals = [];
    let circles = []; // Guild circles around the home castle.
    let dangerZones = [];
    
    // Modified: Changed from object to arrays of lords per team
    const teamLords = {
      "blue": [],
      "red": []
    };
    
    // New: Army size thresholds for attacks
    const MIN_ARMY_SIZE = {
      "blue": 5,
      "red": 5
    };
    
    // New: Track if teams are in attack mode
    const teamAttackMode = {
      "blue": false,
      "red": false
    };
    
    // New: Combat tracking
    const combatStats = {
      "blue": {
        attacksLaunched: 0,
        unitsLost: 0,
        damageDealt: 0,
        lastCombatTime: 0,
        knightEffectiveness: 1.0,
        workerEffectiveness: 1.0
      },
      "red": {
        attacksLaunched: 0,
        unitsLost: 0,
        damageDealt: 0,
        lastCombatTime: 0,
        knightEffectiveness: 1.0,
        workerEffectiveness: 1.0
      }
    };
    
    let unitIdCounter = 0;
    const randomNames = ["Arthur", "Lancelot", "Gawain", "Percival", "Galahad", "Tristan", "Guinevere", "Merlin", "Morgana", "Elaine"];
    
    // --- DangerZone Class ---
    class DangerZone {
      constructor(x, y, radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.decayRate = 0.1;
      }
      update() {
        this.radius -= this.decayRate;
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
        ctx.fill();
        ctx.strokeStyle = 'red';
        ctx.stroke();
      }
      contains(x, y) {
        return Math.hypot(x - this.x, y - this.y) < this.radius;
      }
    }
    
    // --- Helper Functions ---
    function adjustAngleForDangerZones(x, y, angle, speed) {
      let newAngle = angle;
      let nextX = x + Math.cos(angle) * speed;
      let nextY = y + Math.sin(angle) * speed;
      let avoidAngles = [];
      dangerZones.forEach(dz => {
        if (dz.contains(nextX, nextY)) {
          let awayAngle = Math.atan2(nextY - dz.y, nextX - dz.x);
          avoidAngles.push(awayAngle);
        }
      });
      if (avoidAngles.length > 0) {
        let sumX = 0, sumY = 0;
        avoidAngles.forEach(a => {
          sumX += Math.cos(a);
          sumY += Math.sin(a);
        });
        let avgAngle = Math.atan2(sumY, sumX);
        newAngle = newAngle + 0.3 * (((avgAngle + Math.PI) % (2 * Math.PI)) - newAngle);
      }
      return newAngle;
    }
    
    function adjustAngleForEnemies(x, y, angle, speed, selfTeam) {
      let newAngle = angle;
      let avoidAngles = [];
      units.forEach(unit => {
        if (unit.team !== selfTeam && unit.role === "Knight") {
          let d = Math.hypot(unit.x - x, unit.y - y);
          if (d < 150) {
            let awayAngle = Math.atan2(y - unit.y, x - unit.x);
            avoidAngles.push(awayAngle);
          }
        }
      });
      if (avoidAngles.length > 0) {
        let sumX = 0, sumY = 0;
        avoidAngles.forEach(a => {
          sumX += Math.cos(a);
          sumY += Math.sin(a);
        });
        let avgAngle = Math.atan2(sumY, sumX);
        newAngle = newAngle + 0.4 * (((avgAngle + Math.PI) % (2 * Math.PI)) - newAngle);
      }
      return newAngle;
    }
    
    function getNearestCastle(team, x, y) {
      let nearest = null;
      let nearestDist = Infinity;
      castles.forEach(castle => {
        if (castle.team === team) {
          let d = Math.hypot(castle.x - x, castle.y - y);
          if (d < nearestDist) {
            nearestDist = d;
            nearest = castle;
          }
        }
      });
      return { castle: nearest, dist: nearestDist };
    }
    
    // New: Get nearest leader of the same team
    function getNearestLeader(team, x, y, selfId = null) {
      let nearest = null;
      let nearestDist = Infinity;
      
      teamLords[team].forEach(lord => {
        if (lord.id !== selfId) {
          let d = Math.hypot(lord.x - x, lord.y - y);
          if (d < nearestDist) {
            nearestDist = d;
            nearest = lord;
          }
        }
      });
      
      return { leader: nearest, dist: nearestDist };
    }
    
    // New: Count army size for a team
    function getArmySize(team) {
      return units.filter(unit => unit.team === team && (unit.role === "Knight" || unit.role === "Peasant")).length;
    }
    
    // --- Arrow Class (formerly Bullet) ---
    class Arrow {
      constructor(x, y, angle, speed, color, team) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = speed;
        this.color = color;
        this.team = team;
        this.radius = 2;
        this.hit = false;
        this.distanceTraveled = 0;
        this.maxRange = 100;
      }
      update() {
        const dx = Math.cos(this.angle) * this.speed;
        const dy = Math.sin(this.angle) * this.speed;
        this.x += dx;
        this.y += dy;
        this.distanceTraveled += Math.hypot(dx, dy);
        if (this.distanceTraveled > this.maxRange) this.hit = true;
      }
      isInBounds() {
        return this.x >= 0 && this.x <= canvas.width && this.y >= 0 && this.y <= canvas.height;
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
      }
    }
    
    // --- Separation Helper ---
    function applySeparation(unit) {
      let separationForceX = 0, separationForceY = 0;
      const separationDistance = 40;
      units.forEach(other => {
        if (other.id !== unit.id) {
          let dx = unit.x - other.x;
          let dy = unit.y - other.y;
          let dist = Math.hypot(dx, dy);
          if (dist < separationDistance && dist > 0) {
            if (!(other.id in unit.affinities)) {
              unit.affinities[other.id] = Math.random() * 2 - 1;
            }
            let affinity = unit.affinities[other.id];
            let multiplier = (affinity < 0 ? 1 - affinity : 1);
            let force = (separationDistance - dist) * multiplier;
            separationForceX += (dx / dist) * force;
            separationForceY += (dy / dist) * force;
          }
        }
      });
      unit.x += separationForceX * 0.05;
      unit.y += separationForceY * 0.05;
    }
    
    // --- Unit Class (Medieval Units: Lord, Knight, Worker) ---
    class Unit {
      constructor(x, y, size, team, role = "Knight", homeCastle = null) {
        this.id = unitIdCounter++;
        this.affinities = {};
        this.randomName = randomNames[Math.floor(Math.random() * randomNames.length)];
        this.x = x;
        this.y = y;
        this.size = size;
        this.team = team;
        this.role = role; // "Lord", "Knight", or "Worker"
        this.homeCastle = homeCastle;
        this.color = team;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = (role === "Lord") ? 0.5 : Math.random() * 1.5 + 0.5;
        this.arrows = [];
        this.fireCooldown = Math.floor(Math.random() * 100 + 50);
        this.hp = 100;
        this.maxHp = 100;
        // Personality influences decisions.
        this.personality = ["aggressive", "defensive", "friendly", "neutral"][Math.floor(Math.random() * 4)];
        this.message = "";
        this.messageTimer = 0;
        
        // New: Rest state and timers
        this.isResting = false;
        this.restTimer = 0;
        this.timeUntilRest = Math.floor(Math.random() * 600) + 300; // Random time between 5-15 seconds
        
        if (role === "Lord") {
          this.name = "Lord";
          this.orderCycle = ["rally", "build", "rest", "attack"];
          this.orderTimer = 300;
          this.orderIndex = 0;
          // Add this lord to the team's lord array
          if (team in teamLords) {
            teamLords[team].push(this);
          }
        } else if (role === "Knight") {
          this.name = "Knight";
          this.attackRange = 120;
          this.preferredLeader = null; // Will follow a specific leader
        } else {
          this.name = "Worker";
          // Workers have states: "gather", "return", "build", "hunt", "rest"
          this.state = "gather";
          this.carrying = 0;
          this.buildTimer = 200;
        }
      }
      
      communicate(msg) {
        this.message = msg;
        this.messageTimer = 60;
      }
      
      broadcast(msg) {
        units.forEach(u => {
          if (u.team === this.team && Math.hypot(u.x - this.x, u.y - this.y) < 100) {
            u.communicate(msg);
          }
        });
      }
      
      update() {
        // Check if it's time to rest
        if (!this.isResting) {
          this.timeUntilRest--;
          if (this.timeUntilRest <= 0) {
            this.isResting = true;
            this.restTimer = Math.floor(Math.random() * 180) + 120; // Rest for 2-5 seconds
            this.communicate("Taking a break...");
          }
        } else {
          // Unit is resting
          this.restTimer--;
          if (this.restTimer <= 0) {
            this.isResting = false;
            this.timeUntilRest = Math.floor(Math.random() * 600) + 300;
            this.communicate("Break over!");
          } else {
            // During rest, only apply separation to avoid stacking
            applySeparation(this);
            return;
          }
        }
        
        if (this.role === "Lord") {
          updateLord(this);
        } else if (this.role === "Knight") {
          updateKnight(this);
        } else {
          updatePeasant(this);
        }
        applySeparation(this);
      }
      
      fireArrow() {
        if (this.role === "Knight") {
          const arrowSpeed = 5;
          const arrow = new Arrow(this.x, this.y, this.angle, arrowSpeed, this.team, this.team);
          this.arrows.push(arrow);
        }
      }
      
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        if (this.role === "Lord") {
          // Draw the Lord as a crowned circle.
          ctx.beginPath();
          ctx.arc(0, 0, this.size, 0, Math.PI * 2);
          ctx.fillStyle = this.team;
          ctx.fill();
          ctx.fillStyle = "#fff";
          ctx.font = "12px serif";
          ctx.fillText("Crown", -this.size, this.size + 20);
          ctx.fillText(this.orderCycle ? this.orderCycle[this.orderIndex].toUpperCase() : "", -this.size, this.size + 10);
        } else if (this.role === "Knight") {
          // Draw Knight as a shield-like triangle.
          ctx.beginPath();
          ctx.moveTo(this.size, 0);
          ctx.lineTo(-this.size/2, this.size/2);
          ctx.lineTo(-this.size/2, -this.size/2);
          ctx.closePath();
          ctx.fillStyle = this.team;
          ctx.fill();
          this.arrows.forEach(arrow => arrow.draw());
        } else {
          // Draw Peasant as a simple cross.
          ctx.beginPath();
          ctx.moveTo(0, -this.size);
          ctx.lineTo(0, this.size);
          ctx.moveTo(-this.size, 0);
          ctx.lineTo(this.size, 0);
          ctx.strokeStyle = this.team;
          ctx.stroke();
        }
        ctx.restore();
        
        // Draw resting indicator
        if (this.isResting) {
          ctx.beginPath();
          ctx.arc(this.x, this.y - this.size - 5, 3, 0, Math.PI * 2);
          ctx.fillStyle = "#FFFF00";
          ctx.fill();
        }
        
        // Draw name, HP, and personality.
        ctx.fillStyle = "#fff";
        ctx.font = "10px serif";
        ctx.fillText(this.name + " " + this.randomName, this.x - this.size, this.y - this.size - 20);
        ctx.fillText("HP: " + this.hp, this.x - this.size, this.y - this.size - 10);
        ctx.fillText("[" + this.personality + "]", this.x - this.size, this.y - this.size - 5);
        if (this.messageTimer > 0) {
          ctx.fillStyle = "#ff0";
          ctx.font = "10px serif";
          ctx.fillText(this.message, this.x - this.size, this.y - this.size - 30);
          this.messageTimer--;
        }
      }
    }
    
    // --- Update Functions for Medieval Units ---
    function updateLord(unit) {
      unit.orderTimer--;
      if (unit.orderTimer <= 0) {
        unit.orderIndex = (unit.orderIndex + 1) % unit.orderCycle.length;
        unit.orderTimer = 300;
        let order = unit.orderCycle[unit.orderIndex];
        
        if (order === "attack") {
          // Check if army size is sufficient for attack
          const armySize = getArmySize(unit.team);
          if (armySize >= MIN_ARMY_SIZE[unit.team]) {
            unit.communicate("Attack!");
            unit.broadcast("Attack!");
            teamAttackMode[unit.team] = true;
          } else {
            unit.communicate("Army too small: " + armySize + "/" + MIN_ARMY_SIZE[unit.team]);
            unit.broadcast("Build more forces!");
            // Skip attack order
            unit.orderIndex = (unit.orderIndex + 1) % unit.orderCycle.length;
          }
        } else if (order === "rally") {
          unit.communicate("Gather!");
          unit.broadcast("Rally!");
          teamAttackMode[unit.team] = false;
        } else if (order === "build") {
          unit.communicate("Construct!");
          unit.broadcast("Build!");
          teamAttackMode[unit.team] = false;
        } else if (order === "rest") {
          unit.communicate("Take a break!");
          unit.broadcast("Rest!");
          teamAttackMode[unit.team] = false;
        }
      }
      
      // Coordinate with other lords
      const nearestLeader = getNearestLeader(unit.team, unit.x, unit.y, unit.id);
      if (nearestLeader.leader && nearestLeader.dist < 150) {
        // Stay at a comfortable distance from other lords
        let targetAngle = Math.atan2(unit.y - nearestLeader.leader.y, unit.x - nearestLeader.leader.x);
        if (nearestLeader.dist < 50) {
          let diff = targetAngle - unit.angle;
          diff = ((diff + Math.PI) % (2 * Math.PI)) - Math.PI;
          unit.angle += diff * 0.05;
          unit.x += Math.cos(unit.angle) * unit.speed;
          unit.y += Math.sin(unit.angle) * unit.speed;
          return;
        }
      }
      
      if (!unit.currentWaypoint) {
        let candidates = resourceNodes.filter(node => {
          return !dangerZones.some(dz => dz.contains(node.x, node.y));
        });
        if (candidates.length > 0) {
          let best = candidates[0];
          for (let node of candidates) {
            if (node.amount > best.amount) best = node;
          }
          unit.currentWaypoint = { x: best.x, y: best.y };
        } else {
          let rx, ry;
          do {
            rx = Math.random() * canvas.width;
            ry = Math.random() * canvas.height;
          } while (dangerZones.some(dz => dz.contains(rx, ry)));
          unit.currentWaypoint = { x: rx, y: ry };
        }
      }
      
      let dx = unit.currentWaypoint.x - unit.x;
      let dy = unit.currentWaypoint.y - unit.y;
      let distance = Math.hypot(dx, dy);
      let targetAngle = Math.atan2(dy, dx);
      let diff = targetAngle - unit.angle;
      diff = ((diff + Math.PI) % (2 * Math.PI)) - Math.PI;
      unit.angle += diff * 0.05;
      unit.angle = adjustAngleForDangerZones(unit.x, unit.y, unit.angle, unit.speed);
      if (distance < 10) unit.currentWaypoint = null;
      unit.x += Math.cos(unit.angle) * unit.speed;
      unit.y += Math.sin(unit.angle) * unit.speed;
    }
    
    function updateKnight(unit) {
      // If in attack mode, be more aggressive
      const inAttackMode = teamAttackMode[unit.team];
      let rallyDistance = inAttackMode ? 70 : 50;
      
      if (unit.personality === "aggressive") {
        rallyDistance = inAttackMode ? 100 : 40;
      } else if (unit.personality === "defensive") {
        rallyDistance = inAttackMode ? 50 : 60;
      }
      
      // Follow preferred leader or find nearest one
      if (!unit.preferredLeader || !teamLords[unit.team].includes(unit.preferredLeader)) {
        // Randomly assign to one of the team's lords
        if (teamLords[unit.team].length > 0) {
          unit.preferredLeader = teamLords[unit.team][Math.floor(Math.random() * teamLords[unit.team].length)];
        }
      }
      
      const lord = unit.preferredLeader;
      
      if (lord) {
        let dToLord = Math.hypot(unit.x - lord.x, unit.y - lord.y);
        if (dToLord > rallyDistance && (!inAttackMode || unit.personality !== "aggressive")) {
          let targetAngle = Math.atan2(lord.y - unit.y, lord.x - unit.x);
          let diff = targetAngle - unit.angle;
          diff = ((diff + Math.PI) % (2 * Math.PI)) - Math.PI;
          unit.angle += diff * 0.1;
          unit.angle = adjustAngleForDangerZones(unit.x, unit.y, unit.angle, unit.speed);
          unit.x += Math.cos(unit.angle) * unit.speed;
          unit.y += Math.sin(unit.angle) * unit.speed;
          return;
        }
      }
      
      // Only search for enemies if in attack mode or aggressive
      let enemy = null;
      let closestDistance = Infinity;
      
      if (inAttackMode || unit.personality === "aggressive") {
        units.forEach(u => {
          if (u !== unit && u.team !== unit.team && u.role !== "Lord") {
            let d = Math.hypot(u.x - unit.x, u.y - unit.y);
            if (d < closestDistance) {
              closestDistance = d;
              enemy = u;
            }
          }
        });
      }
      
      if (enemy) {
        if (unit.personality === "aggressive" || inAttackMode) {
          let targetAngle = Math.atan2(enemy.y - unit.y, enemy.x - unit.x);
          let diff = targetAngle - unit.angle;
          diff = ((diff + Math.PI) % (2 * Math.PI)) - Math.PI;
          unit.angle += diff * 0.1;
          unit.communicate("Charge!");
        } else if (unit.personality === "defensive") {
          if (closestDistance < unit.attackRange / 2) {
            let retreatAngle = Math.atan2(unit.y - enemy.y, unit.x - enemy.x);
            let diff = retreatAngle - unit.angle;
            diff = ((diff + Math.PI) % (2 * Math.PI)) - Math.PI;
            unit.angle += diff * 0.1;
            unit.communicate("Retreat!");
          } else {
            let targetAngle = Math.atan2(enemy.y - unit.y, enemy.x - unit.x);
            let diff = targetAngle - unit.angle;
            diff = ((diff + Math.PI) % (2 * Math.PI)) - Math.PI;
            unit.angle += diff * 0.05;
            unit.communicate("Hold position");
          }
        } else if (unit.personality === "friendly") {
          if (closestDistance < unit.attackRange) {
            let targetAngle = Math.atan2(enemy.y - unit.y, enemy.x - unit.x);
            let diff = targetAngle - unit.angle;
            diff = ((diff + Math.PI) % (2 * Math.PI)) - Math.PI;
            unit.angle += diff * 0.05;
            unit.communicate("Be alert!");
          }
        } else {
          let targetAngle = Math.atan2(enemy.y - unit.y, enemy.x - unit.x);
          let diff = targetAngle - unit.angle;
          diff = ((diff + Math.PI) % (2 * Math.PI)) - Math.PI;
          unit.angle += diff * 0.05;
        }
      }
      
      unit.angle = adjustAngleForDangerZones(unit.x, unit.y, unit.angle, unit.speed);
      unit.x += Math.cos(unit.angle) * unit.speed;
      unit.y += Math.sin(unit.angle) * unit.speed;
      if (unit.x < 0 || unit.x > canvas.width) unit.angle = Math.PI - unit.angle;
      if (unit.y < 0 || unit.y > canvas.height) unit.angle = -unit.angle;
      
                if (enemy && Math.hypot(enemy.x - unit.x, enemy.y - unit.y) < unit.attackRange && 
          (inAttackMode || unit.personality === "aggressive")) {
        if (unit.fireCooldown <= 0) {
          unit.fireArrow();
          
          // Record combat activity
          combatStats[unit.team].attacksLaunched++;
          combatStats[unit.team].lastCombatTime = performance.now();
          
          unit.fireCooldown = Math.floor(Math.random() * 100 + 50);
        } else {
          unit.fireCooldown--;
        }
      } else {
        if (unit.fireCooldown > 0) unit.fireCooldown--;
      }
      
      unit.arrows.forEach(arrow => arrow.update());
      unit.arrows = unit.arrows.filter(arrow => arrow.isInBounds() && !arrow.hit);
    }
    
    function updatePeasant(unit) {
      // Workers will gather resources and may hunt animals if available.
      if (unit.state === "gather" && unit.carrying === 0) {
        let targetNode = null;
        let closestDist = Infinity;
        resourceNodes.forEach(node => {
          let d = Math.hypot(node.x - unit.x, node.y - unit.y);
          if (d < closestDist) {
            closestDist = d;
            targetNode = node;
          }
        });
        if (targetNode) {
          let targetAngle = Math.atan2(targetNode.y - unit.y, targetNode.x - unit.x);
          let diff = targetAngle - unit.angle;
          diff = ((diff + Math.PI) % (2 * Math.PI)) - Math.PI;
          unit.angle += diff * 0.05;
          unit.angle = adjustAngleForEnemies(unit.x, unit.y, unit.angle, unit.speed, unit.team);
          unit.angle = adjustAngleForDangerZones(unit.x, unit.y, unit.angle, unit.speed);
          unit.x += Math.cos(unit.angle) * unit.speed;
          unit.y += Math.sin(unit.angle) * unit.speed;
          if (Math.hypot(targetNode.x - unit.x, targetNode.y - unit.y) < 10) {
            // Wood provides 5 resources per gather (instead of up to 10)
            const collected = 5;
            // No depletion of wood nodes
            unit.carrying += collected;
            unit.communicate("Collected resources!");
            let nearest = getNearestCastle(unit.team, unit.x, unit.y);
            if (nearest.castle && nearest.dist < 150) {
              unit.state = "return";
              unit.communicate("Returning to castle");
            } else {
              unit.state = "build";
              unit.communicate("Preparing to build");
            }
          }
        } else {
          // Look for nearby animals to hunt.
          let targetAnimal = null;
          let animalDist = Infinity;
          animals.forEach(animal => {
            let d = Math.hypot(animal.x - unit.x, animal.y - unit.y);
            if (d < animalDist) {
              animalDist = d;
              targetAnimal = animal;
            }
          });
          if (targetAnimal && animalDist < 100) {
            let targetAngle = Math.atan2(targetAnimal.y - unit.y, targetAnimal.x - unit.x);
            let diff = targetAngle - unit.angle;
            diff = ((diff + Math.PI) % (2 * Math.PI)) - Math.PI;
            unit.angle += diff * 0.05;
            unit.communicate("Hunting animal!");
            if (animalDist < 10) {
              targetAnimal.hp -= 50;
              if (targetAnimal.hp <= 0) {
                unit.carrying += 20;
                animals = animals.filter(a => a !== targetAnimal);
              }
            }
            unit.x += Math.cos(unit.angle) * unit.speed;
            unit.y += Math.sin(unit.angle) * unit.speed;
          } else {
            unit.angle = adjustAngleForEnemies(unit.x, unit.y, unit.angle, unit.speed, unit.team);
            unit.angle = adjustAngleForDangerZones(unit.x, unit.y, unit.angle, unit.speed);
            unit.x += Math.cos(unit.angle) * unit.speed;
            unit.y += Math.sin(unit.angle) * unit.speed;
            unit.communicate("Searching...");
          }
        }
      } else if (unit.state === "return") {
        let nearest = getNearestCastle(unit.team, unit.x, unit.y);
        if (nearest.castle) {
          let targetAngle = Math.atan2(nearest.castle.y - unit.y, nearest.castle.x - unit.x);
          let diff = targetAngle - unit.angle;
          diff = ((diff + Math.PI) % (2 * Math.PI)) - Math.PI;
          unit.angle += diff * 0.1;
          unit.angle = adjustAngleForDangerZones(unit.x, unit.y, unit.angle, unit.speed);
          unit.x += Math.cos(unit.angle) * unit.speed;
          unit.y += Math.sin(unit.angle) * unit.speed;
          unit.communicate("Returning!");
          if (Math.hypot(unit.x - nearest.castle.x, unit.y - nearest.castle.y) < 15) {
            nearest.castle.resources += unit.carrying;
            unit.carrying = 0;
            unit.state = "gather";
            unit.communicate("Deposited resources");
          }
        } else {
          unit.state = "build";
          unit.communicate("No castle found!");
        }
      } else if (unit.state === "build") {
        // If resources drop below threshold, revert to gathering.
        if (unit.carrying < 50) {
          unit.state = "gather";
          unit.communicate("Not enough resources, gathering more!");
        } else {
          unit.buildTimer--;
          unit.communicate("Building...");
          if (unit.buildTimer <= 0 && unit.carrying >= 50) {
            unit.carrying -= 50;
            castles.push(new Castle(unit.x, unit.y, unit.team));
            unit.buildTimer = 200;
            unit.state = "gather";
            unit.communicate("Castle built!");
          }
        }
      }
    }
    
    // --- Castle Class (Special castle generates resources slowly) ---
    class Castle {
      constructor(x, y, team, resources = 0, special = false, townName = "") {
        this.x = x;
        this.y = y;
        this.team = team;
        this.resources = resources;
        this.spawnTimer = 300;
        this.hp = 200;
        this.special = special;
        this.townName = townName;
        this.resourceGenCounter = 0;
      }
      
      calculateUnitWeights() {
        // Calculate weights based on combat stats and excess resources
        const stats = combatStats[this.team];
        const currentTime = performance.now();
        const timeSinceLastCombat = (currentTime - stats.lastCombatTime) / 1000; // in seconds
        
        // Base weights
        let lordWeight = 0.1;  // Lowest priority by default
        let knightWeight = 0.5;
        let workerWeight = 0.4;
        
        // Adjust based on combat effectiveness
        knightWeight *= stats.knightEffectiveness;
        workerWeight *= stats.workerEffectiveness;
        
        // Adjust based on resource surplus
        const resourceSurplus = this.resources > 200;
        if (resourceSurplus) {
          lordWeight *= 2; // More likely to create leaders with resource surplus
        }
        
        // Adjust based on recent combat
        const recentCombat = timeSinceLastCombat < 10; // Less than 10 seconds
        if (recentCombat) {
          knightWeight *= 1.5; // Prioritize knights during combat
          workerWeight *= 0.5; // Deprioritize workers during combat
        } else if (timeSinceLastCombat > 30) {
          // No combat for a while, focus on economy
          workerWeight *= 1.5;
          knightWeight *= 0.8;
        }
        
        // Adjust based on unit losses
        if (stats.unitsLost > 0) {
          // Replace the type of units that were lost
          if (getArmySize(this.team) < MIN_ARMY_SIZE[this.team]) {
            knightWeight *= 1.5; // Need to rebuild the army
          }
        }
        
        // Normalize weights
        const total = lordWeight + knightWeight + workerWeight;
        return {
          lord: lordWeight / total,
          knight: knightWeight / total,
          worker: workerWeight / total
        };
      }
      
      update() {
        // Special castle generates 1 resource per second (~60 frames).
        if (this.special) {
          this.resourceGenCounter++;
          if (this.resourceGenCounter >= 60) {
            this.resources++;
            this.resourceGenCounter = 0;
          }
        }
        this.spawnTimer--;
        if (this.spawnTimer <= 0) {
          // Calculate weights for each unit type
          const weights = this.calculateUnitWeights();
          const random = Math.random();
          
          // Use weights to determine what to spawn
          let unitType = null;
          let cumulativeWeight = 0;
          
          // Lord check (need at least 100 resources)
          if (this.resources >= 100) {
            cumulativeWeight += weights.lord;
            if (random < cumulativeWeight) {
              unitType = "Lord";
            }
          }
          
          // Knight check (need at least 50 resources)
          if (unitType === null && this.resources >= 50) {
            cumulativeWeight += weights.knight;
            if (random < cumulativeWeight) {
              unitType = "Knight";
            }
          }
          
          // Worker check (need at least 25 resources)
          if (unitType === null && this.resources >= 25) {
            unitType = "Worker"; // Default if nothing else is selected
          }
          
          // Spawn the unit based on selection
          if (unitType === "Lord" && this.resources >= 100) {
            let lord = new Unit(
              this.x + (Math.random()-0.5)*20,
              this.y + (Math.random()-0.5)*20,
              15,
              this.team,
              "Lord",
              this
            );
            units.push(lord);
            this.resources -= 100;
          } else if (unitType === "Knight" && this.resources >= 50) {
            let knight = new Unit(
              this.x + (Math.random()-0.5)*20,
              this.y + (Math.random()-0.5)*20,
              Math.random()*10 + 15,
              this.team,
              "Knight",
              this
            );
            if (teamLords[this.team].length > 0) {
              knight.preferredLeader = teamLords[this.team][Math.floor(Math.random() * teamLords[this.team].length)];
            }
            units.push(knight);
            this.resources -= 50;
          } else if (unitType === "Worker" && this.resources >= 25) {
            let worker = new Unit(
              this.x + (Math.random()-0.5)*20,
              this.y + (Math.random()-0.5)*20,
              Math.random()*10 + 15,
              this.team,
              "Worker",
              this
            );
            units.push(worker);
            this.resources -= 25;
          }
          this.spawnTimer = 300;
        }
      }
      draw() {
        // Draw the castle as a fortified structure.
        ctx.beginPath();
        ctx.rect(this.x - 20, this.y - 20, 40, 40);
        ctx.fillStyle = this.team;
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.stroke();
        ctx.fillStyle = "#fff";
        ctx.font = "12px serif";
        ctx.fillText("Resources: " + this.resources, this.x - 30, this.y - 30);
        ctx.fillText("HP: " + this.hp, this.x - 30, this.y - 15);
        if (this.special) {
          ctx.fillText(this.townName, this.x - 30, this.y - 45);
        }
      }
    }
    
    // --- Resource Node Class (Wood) ---
    class ResourceNode {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        // No longer used for depletion, but kept for compatibility
        this.amount = Infinity;
      }
      draw() {
        // Tree-like appearance
        ctx.beginPath();
        ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
        ctx.fillStyle = "#8B4513"; // Saddle brown for trunk
        ctx.fill();
        
        // Draw tree top
        ctx.beginPath();
        ctx.arc(this.x, this.y - 8, 15, 0, Math.PI * 2);
        ctx.fillStyle = "#228B22"; // Forest green for leaves
        ctx.fill();
        
        ctx.fillStyle = "#fff";
        ctx.font = "10px serif";
        ctx.fillText("Wood", this.x - 14, this.y - 20);
      }
    }
    
    // --- Animal Class (Roaming animals for hunting) ---
    class Animal {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.hp = 50;
        this.speed = Math.random() * 1 + 0.5;
        this.angle = Math.random() * Math.PI * 2;
      }
      update() {
        this.angle += (Math.random() - 0.5) * 0.1;
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        if (this.x < 0 || this.x > canvas.width) this.angle = Math.PI - this.angle;
        if (this.y < 0 || this.y > canvas.height) this.angle = -this.angle;
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
        ctx.fillStyle = "brown";
        ctx.fill();
        ctx.fillStyle = "#fff";
        ctx.font = "8px serif";
        ctx.fillText("Animal", this.x - 15, this.y - 10);
      }
    }
    
    // --- Circle Class (Guild Circles around the home castle) ---
    class Circle {
      constructor(x, y, team, homeCastle) {
        this.x = x;
        this.y = y;
        this.team = team;
        this.homeCastle = homeCastle;
        // Jobs: "miner", "builder", "hunter", "defender"
        this.job = ["miner", "builder", "hunter", "defender"][Math.floor(Math.random()*4)];
        this.size = 15;
        this.speed = 1;
      }
      update() {
        // Hover near the home castle.
        let targetX = this.homeCastle.x + (Math.random()-0.5)*50;
        let targetY = this.homeCastle.y + (Math.random()-0.5)*50;
        let dx = targetX - this.x;
        let dy = targetY - this.y;
        let angle = Math.atan2(dy, dx);
        this.x += Math.cos(angle) * this.speed;
        this.y += Math.sin(angle) * this.speed;
        
        // Switch jobs based on conditions near the castle.
        if (this.homeCastle.resources < 50) {
          this.job = "miner";
        } else if (animals.length > 3) {
          this.job = "hunter";
        } else if (units.filter(u => u.team === this.team && u.role === "Peasant").length < 3) {
          this.job = "builder";
        } else {
          this.job = "defender";
        }
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.team;
        ctx.fill();
        ctx.fillStyle = "#fff";
        ctx.font = "10px serif";
        ctx.fillText(this.job, this.x - this.size, this.y - this.size - 5);
      }
    }
    
    // --- Initialize Special Castle (Home Castle) ---
    // Team "blue" will be the player's side.
    let homeCastle = new Castle(100, canvas.height/2, "blue", 100, true, "Camelot");
    castles.push(homeCastle);
    let blueLord = new Unit(130, canvas.height/2, 15, "blue", "Lord");
    units.push(blueLord);
    
    // Initialize an enemy castle for team "red".
    let enemyCastle = new Castle(canvas.width - 100, canvas.height/2, "red", 100);
    castles.push(enemyCastle);
    let redLord = new Unit(canvas.width - 130, canvas.height/2, 15, "red", "Lord");
    units.push(redLord);
    
    // --- Initialize Knights and Peasants ---
    ["blue", "red"].forEach(team => {
      for (let i = 0; i < 3; i++){
        let x = team==="blue" ? 150 + Math.random()*50 : canvas.width - 150 + (Math.random()-0.5)*50;
        let y = canvas.height/2 + (Math.random()-0.5)*100;
        let knight = new Unit(x, y, Math.random()*10+15, team, "Knight", "Knight");
        knight.preferredLeader = team === "blue" ? blueLord : redLord;
        units.push(knight);
      }
    });
    
    // --- Initialize Resource Nodes ---
    for (let i = 0; i < 5; i++){
      let x = Math.random() * canvas.width;
      let y = Math.random() * canvas.height;
      resourceNodes.push(new ResourceNode(x, y));
    }
    
    // --- Initialize Animals ---
    for (let i = 0; i < 5; i++){
      let x = Math.random() * canvas.width;
      let y = Math.random() * canvas.height;
      animals.push(new Animal(x, y));
    }
    
    // --- Initialize Guild Circles (up to 4) around the home castle ---
    for (let i = 0; i < 4; i++){
      let angle = (i / 4) * Math.PI * 2;
      let x = homeCastle.x + Math.cos(angle) * 60;
      let y = homeCastle.y + Math.sin(angle) * 60;
      circles.push(new Circle(x, y, "blue", homeCastle));
    }
    
    // --- Collision Detection ---
    function checkCollisions() {
      const unitsToRemove = new Set();
      units.forEach(shooter => {
        if (shooter.role === "Knight") {
          shooter.arrows.forEach(arrow => {
            units.forEach(target => {
              if (target.team !== shooter.team && target.role !== "Lord") {
                const dx = arrow.x - target.x;
                const dy = arrow.y - target.y;
                if (Math.hypot(dx, dy) < target.size/2) {
                  arrow.hit = true;
                  target.hp -= 50;
                  
                  // Record damage for combat stats
                  combatStats[shooter.team].damageDealt += 50;
                  combatStats[shooter.team].lastCombatTime = performance.now();
                  
                  if (target.hp <= 0) {
                    unitsToRemove.add(target);
                    
                    // Record unit loss in combat stats
                    combatStats[target.team].unitsLost++;
                    combatStats[target.team].lastCombatTime = performance.now();
                    
                    // Update unit effectiveness based on which type was lost
                    if (target.role === "Knight") {
                      combatStats[target.team].knightEffectiveness *= 0.95; // Knights becoming less effective
                      combatStats[shooter.team].knightEffectiveness *= 1.05; // Winner's knights more effective
                    } else if (target.role === "Worker") {
                      combatStats[target.team].workerEffectiveness *= 0.95; // Workers becoming less effective
                    }
                    
                    let zoneFound = false;
                    dangerZones.forEach(zone => {
                      if (Math.hypot(zone.x - target.x, zone.y - target.y) < 50) {
                        zone.radius += 20;
                        zoneFound = true;
                      }
                    });
                    if (!zoneFound) {
                      dangerZones.push(new DangerZone(target.x, target.y, 40));
                    }
                  }
                }
              }
            });
          });
        }
      });
      units = units.filter(unit => !unitsToRemove.has(unit));
      
      const castlesToRemove = new Set();
      units.forEach(unit => {
        if (unit.role === "Knight") {
          unit.arrows.forEach(arrow => {
            castles.forEach(castle => {
              if (arrow.team !== castle.team) {
                const dx = arrow.x - castle.x;
                const dy = arrow.y - castle.y;
                if (Math.hypot(dx, dy) < 20) {
                  arrow.hit = true;
                  castle.hp -= 50;
                  if (castle.hp <= 0) {
                    castlesToRemove.add(castle);
                  }
                }
              }
            });
          });
        }
      });
      castles = castles.filter(castle => {
        if (castlesToRemove.has(castle)) {
          let zoneFound = false;
          dangerZones.forEach(zone => {
            if (Math.hypot(zone.x - castle.x, zone.y - castle.y) < 50) {
              zone.radius += 20;
              zoneFound = true;
            }
          });
          if (!zoneFound) {
            dangerZones.push(new DangerZone(castle.x, castle.y, 40));
          }
          return false;
        }
        return true;
      });
      
      units.forEach(unit => {
        if (unit.role === "Knight") {
          unit.arrows = unit.arrows.filter(arrow => arrow.isInBounds() && !arrow.hit);
        }
      });
    }
    
    // --- Main Animation Loop ---
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw game information
      ctx.fillStyle = "#fff";
      ctx.font = "14px serif";
      
      // Display army info
      ctx.fillText("Blue Army: " + getArmySize("blue") + "/" + MIN_ARMY_SIZE["blue"] + " units", 20, 20);
      ctx.fillText("Red Army: " + getArmySize("red") + "/" + MIN_ARMY_SIZE["red"] + " units", canvas.width - 200, 20);
      
      // Display leader info
      ctx.fillText("Blue Leaders: " + teamLords["blue"].length, 20, 40);
      ctx.fillText("Red Leaders: " + teamLords["red"].length, canvas.width - 200, 40);
      
      // Display combat stats
      const blueKnights = units.filter(u => u.team === "blue" && u.role === "Knight").length;
      const blueWorkers = units.filter(u => u.team === "blue" && u.role === "Worker").length;
      const redKnights = units.filter(u => u.team === "red" && u.role === "Knight").length;
      const redWorkers = units.filter(u => u.team === "red" && u.role === "Worker").length;
      
      ctx.fillText("Blue: " + blueKnights + " Knights, " + blueWorkers + " Workers", 20, 60);
      ctx.fillText("Red: " + redKnights + " Knights, " + redWorkers + " Workers", canvas.width - 200, 60);
      
      // Show resource and production preference
      const blueCastle = castles.find(c => c.team === "blue" && c.special);
      const redCastle = castles.find(c => c.team === "red" && c.special);
      
      if (blueCastle) {
        const blueWeights = blueCastle.calculateUnitWeights();
        ctx.fillText("Blue Resources: " + blueCastle.resources, 20, 80);
        ctx.fillText("Weights: K:" + blueWeights.knight.toFixed(2) + " W:" + blueWeights.worker.toFixed(2) + " L:" + blueWeights.lord.toFixed(2), 20, 100);
      }
      
      if (redCastle) {
        const redWeights = redCastle.calculateUnitWeights();
        ctx.fillText("Red Resources: " + redCastle.resources, canvas.width - 200, 80);
        ctx.fillText("Weights: K:" + redWeights.knight.toFixed(2) + " W:" + redWeights.worker.toFixed(2) + " L:" + redWeights.lord.toFixed(2), canvas.width - 200, 100);
      }
      
      dangerZones.forEach(zone => zone.update());
      dangerZones = dangerZones.filter(zone => zone.radius > 5);
      dangerZones.forEach(zone => zone.draw());
      
      castles.forEach(castle => castle.update());
      // Wood nodes don't need filtering since they don't deplete
      animals.forEach(animal => animal.update());
      circles.forEach(circle => circle.update());
      units.forEach(unit => unit.update());
      checkCollisions();
      
      resourceNodes.forEach(node => node.draw());
      animals.forEach(animal => animal.draw());
      circles.forEach(circle => circle.draw());
      castles.forEach(castle => castle.draw());
      units.forEach(unit => unit.draw());
      
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>